<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>面向对象7大设计原则 | Goat Blog</title><meta name="description" content="面向对象7大设计原则"><meta name="keywords" content="设计模式,面向对象,设计原则"><meta name="author" content="GoatSheep"><meta name="copyright" content="GoatSheep"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="面向对象7大设计原则"><meta name="twitter:description" content="面向对象7大设计原则"><meta name="twitter:image" content="https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/shejiyuanze.png"><meta property="og:type" content="article"><meta property="og:title" content="面向对象7大设计原则"><meta property="og:url" content="https://goatsheep999.github.io/goat/1545206466/"><meta property="og:site_name" content="Goat Blog"><meta property="og:description" content="面向对象7大设计原则"><meta property="og:image" content="https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/shejiyuanze.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://goatsheep999.github.io/goat/1545206466/"><link rel="prev" title="Effective Java学习笔记" href="https://goatsheep999.github.io/goat/4223960172/"><link rel="next" title="设计模式之工厂方法模式" href="https://goatsheep999.github.io/goat/factory_method/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://goatsheep999.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: GoatSheep","link":"链接: https://goatsheep999.github.io/goat/1545206466/","source":"来源: Goat Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Goat Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#概述"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#相互关系"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">相互关系</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#开闭原则（The-Open-Closed-Principle-OCP）"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">开闭原则（The Open-Closed Principle, OCP）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#定义"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何使用"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">如何使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#案例"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">案例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#单一职责原则"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">单一职责原则</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#定义-1"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#解释"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">解释</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#里氏替换原则（LISKOV-SUBSTITUTION-PRINCLPLE-LSP）"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">里氏替换原则（LISKOV SUBSTITUTION PRINCLPLE, LSP）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#定义-2"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#解释-1"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#举个栗子"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">举个栗子</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#依赖倒置原则（DEPENDENCY-INVERSION-PRINCIPLE-DIP）"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">依赖倒置原则（DEPENDENCY INVERSION PRINCIPLE, DIP）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#定义-3"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#解释-2"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何使用-1"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">如何使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#接口分离原则（INTERFACE-SEGREGATION-PRINCIPLE-ISP）"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">接口分离原则（INTERFACE SEGREGATION PRINCIPLE, ISP）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#定义-4"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何使用-2"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">如何使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#合成-复用原则（COMPOSITE-AGGREGATE-REUSE-PRINCIPLE-CARP）"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">合成&#x2F;复用原则（COMPOSITE&#x2F;AGGREGATE REUSE PRINCIPLE, CARP）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#定义-5"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text">定义</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#合成"><span class="toc_mobile_items-number">8.1.1.</span> <span class="toc_mobile_items-text">合成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#聚合"><span class="toc_mobile_items-number">8.1.2.</span> <span class="toc_mobile_items-text">聚合</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#为什么用合成-聚合来代替继承达到复用的目的？"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text">为什么用合成&#x2F;聚合来代替继承达到复用的目的？</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#迪米特原则（LAW-OF-DEMETER-LOD）"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">迪米特原则（LAW OF DEMETER, LOD）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#定义-6"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text">定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#解释-3"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text">解释</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#如何使用-3"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text">如何使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#参考"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">参考</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#相互关系"><span class="toc-number">2.</span> <span class="toc-text">相互关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开闭原则（The-Open-Closed-Principle-OCP）"><span class="toc-number">3.</span> <span class="toc-text">开闭原则（The Open-Closed Principle, OCP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用"><span class="toc-number">3.2.</span> <span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#案例"><span class="toc-number">3.3.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单一职责原则"><span class="toc-number">4.</span> <span class="toc-text">单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-1"><span class="toc-number">4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释"><span class="toc-number">4.2.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#里氏替换原则（LISKOV-SUBSTITUTION-PRINCLPLE-LSP）"><span class="toc-number">5.</span> <span class="toc-text">里氏替换原则（LISKOV SUBSTITUTION PRINCLPLE, LSP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-2"><span class="toc-number">5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释-1"><span class="toc-number">5.2.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#举个栗子"><span class="toc-number">5.3.</span> <span class="toc-text">举个栗子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#依赖倒置原则（DEPENDENCY-INVERSION-PRINCIPLE-DIP）"><span class="toc-number">6.</span> <span class="toc-text">依赖倒置原则（DEPENDENCY INVERSION PRINCIPLE, DIP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-3"><span class="toc-number">6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释-2"><span class="toc-number">6.2.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用-1"><span class="toc-number">6.3.</span> <span class="toc-text">如何使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口分离原则（INTERFACE-SEGREGATION-PRINCIPLE-ISP）"><span class="toc-number">7.</span> <span class="toc-text">接口分离原则（INTERFACE SEGREGATION PRINCIPLE, ISP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-4"><span class="toc-number">7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用-2"><span class="toc-number">7.2.</span> <span class="toc-text">如何使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#合成-复用原则（COMPOSITE-AGGREGATE-REUSE-PRINCIPLE-CARP）"><span class="toc-number">8.</span> <span class="toc-text">合成&#x2F;复用原则（COMPOSITE&#x2F;AGGREGATE REUSE PRINCIPLE, CARP）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-5"><span class="toc-number">8.1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#合成"><span class="toc-number">8.1.1.</span> <span class="toc-text">合成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚合"><span class="toc-number">8.1.2.</span> <span class="toc-text">聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么用合成-聚合来代替继承达到复用的目的？"><span class="toc-number">8.2.</span> <span class="toc-text">为什么用合成&#x2F;聚合来代替继承达到复用的目的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#迪米特原则（LAW-OF-DEMETER-LOD）"><span class="toc-number">9.</span> <span class="toc-text">迪米特原则（LAW OF DEMETER, LOD）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义-6"><span class="toc-number">9.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解释-3"><span class="toc-number">9.2.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何使用-3"><span class="toc-number">9.3.</span> <span class="toc-text">如何使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">10.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/shejiyuanze.png)"><div id="post-info"><div id="post-title"><div class="posttitle">面向对象7大设计原则</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-03-06<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-03-06</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">设计原则</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;7大设计原则是老前辈们多年总结的经验，掌握并能灵活运用到实际工作中可以帮助我们解决很多实际问题。这也是程序员架构之路上躲不开的一道槛，只有掌握了7大原则才能对代码进行高水平的重构，对源码的解读也会更加轻松。</p>
<p>&emsp;&emsp;用抽象构建架构，用实现扩展细节是所有代码设计模式的基础，设计原则的出现是为了提高系统的可维护性和可复用性，提高系统的高内聚和低耦合。</p>
<p>&emsp;&emsp;7大原则包括：<b>开闭原则、里氏替换原则、迪米特原则(最少知道原则)、单一职责原则、接口分离原则、依赖倒置原则、合成/聚合复用原则</b>。</p>
<h1 id="相互关系"><a href="#相互关系" class="headerlink" title="相互关系"></a>相互关系</h1><p>&emsp;&emsp;7大原则并不是互相独立的，彼此间存在一定的联系，遵守了其中一个，可能也违反了其余的原则。</p>
<p>&emsp;&emsp;开闭原则是面向对象的可复用设计的基石，其它设计原则都是实现开闭原则的手段和工具。</p>
<p>&emsp;&emsp;一般地，可以把7大原则分为两个部分：</p>
<ul>
<li>设计目标：开闭原则、里氏替换原则、迪米特原则</li>
<li>设计方法：单一职责原则、接口分离原则、依赖倒置原则、合成/复用原则</li>
</ul>
<h1 id="开闭原则（The-Open-Closed-Principle-OCP）"><a href="#开闭原则（The-Open-Closed-Principle-OCP）" class="headerlink" title="开闭原则（The Open-Closed Principle, OCP）"></a>开闭原则（The Open-Closed Principle, OCP）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;开闭原则指一个软件实体如类、模块和方法应该对扩展开放，对修改关闭。就是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><ol>
<li>抽象约束</li>
</ol>
<ul>
<li><p>通过接口或者抽象类约束扩展，对扩展进行边界界定，不允许出现在接口或抽象类中不存在的public方法；</p>
</li>
<li><p>参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；</p>
</li>
<li><p>抽象层尽量保持稳定，一旦确定即不允许修改。</p>
</li>
</ul>
<ol start="2">
<li>元数据（metadata）控制模块行为</li>
</ol>
<p>&emsp;&emsp;元数据就是用来描述环境和数据的数据，参数可以从文件中获得，也可以从数据库中获得。Spring容器就是一个典型的元数据控制模块行为的例子，其中达到极致的就是控制反转（Inversion of Control）</p>
<ol start="3">
<li>制定项目章程</li>
</ol>
<p>&emsp;&emsp;在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，<b>约定优于配置</b>。</p>
<ol start="4">
<li>封装变化</li>
</ol>
<p>&emsp;&emsp;将相同的变化封装到一个接口或者抽象类中；将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>&emsp;&emsp;因为之前写了一个<a href="/goat/2580072625/" title="工厂方法模式">工厂方法模式</a>，是符合开闭原则的，这里就不写代码了。</p>
<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;一个类或者模块应该有且只有一个改变的原因。如果一个类承担的职责过多，就等于把这些这则耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发送变化时，设计会遭到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心是解耦合和增强内聚性。</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>&emsp;&emsp;单一职责原则告诉我们：一个类不能做太多的东西。在软件系统中，一个类(一个模块、或者一个方法)承担的职责越多，那么其被复用的可能性就会越低。一个很典型的例子就是万能类。其实可以说一句大实话：任何一个常规的MVC项目，在极端的情况下，可以用一个类(甚至一个方法)完成所有的功能。但是这样做就会严重耦合，甚至牵一发动全身。一个类承(一个模块、或者一个方法)担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>
<p>&emsp;&emsp;不过说实话，其实有的时候很难去衡量一个类的职责，主要是很难确定职责的粒度。这一点不仅仅体现在一个类或者一个模块中，也体现在采用微服务的分布式系统中。这也就是为什么我们在实施微服务拆分的时候经常会撕逼：”这个功能不应该发在A服务中，它不做这个领域的东西，应该放在B服务中”诸如此类的争论。存在争论是合理的，不过最好不要不了了之，而应该按照领域定义好每个服务的职责(职责的粒度最好找业务和架构专家咨询)，得出相对合理的职责分配。</p>
<h1 id="里氏替换原则（LISKOV-SUBSTITUTION-PRINCLPLE-LSP）"><a href="#里氏替换原则（LISKOV-SUBSTITUTION-PRINCLPLE-LSP）" class="headerlink" title="里氏替换原则（LISKOV SUBSTITUTION PRINCLPLE, LSP）"></a>里氏替换原则（LISKOV SUBSTITUTION PRINCLPLE, LSP）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;所有引用基类的地方必须能透明的使用其子类对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。</p>
<h2 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h2><p>&emsp;&emsp;只有当子类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而子类也能够在基类的基础上增加新的行为。里氏替换原则是对开-闭原则的补充。实现开-闭原则的关键步骤是<b>抽象化</b>。而基类与子类的继承关系就是抽象化的具体体现，所以里氏替换原则是对实现抽象化的具体步骤的规范。当然，如果反过来，软件单位使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>&emsp;&emsp;里氏替换原则是实现开闭原则的基础，它告诉我们在设计程序的时候尽可能使用基类进行对象的定义和引用，在运行时再决定基类的具体子类型。</p>
<p>&emsp;&emsp;定义一个Animal类</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>&emsp;&emsp;让其子类实现基类方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 猫类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"狗吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>&emsp;&emsp;调用者</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 运行时决定子类型</span></span><br><span class="line">        Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.eat();</span><br><span class="line"></span><br><span class="line">        Animal dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="依赖倒置原则（DEPENDENCY-INVERSION-PRINCIPLE-DIP）"><a href="#依赖倒置原则（DEPENDENCY-INVERSION-PRINCIPLE-DIP）" class="headerlink" title="依赖倒置原则（DEPENDENCY INVERSION PRINCIPLE, DIP）"></a>依赖倒置原则（DEPENDENCY INVERSION PRINCIPLE, DIP）</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;程序要依赖与抽象接口，不要依赖于具体实现。简单的说就是要对抽象(接口)编程，不要对实现进行编程，这样就降低了调用者和实现模块间的耦合。</p>
<h2 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h2><p>&emsp;&emsp;依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p>
<h2 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h2><ul>
<li>高层模块不应该依赖低层模块，高层模块和低层模块都应该依赖于抽象。</li>
<li>抽象不应该依赖具体，具体应该依赖抽象。</li>
</ul>
<p>&emsp;&emsp;在实现依赖倒置原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。Spring的IOC是此实现的典范。</p>
<p>&emsp;&emsp;从Java角度看待依赖倒转原则的本质就是：面向接口(抽象)编程。</p>
<ul>
<li>每个具体的类都应该有其接口或者基类，或者两者都具备。</li>
<li>类中的引用对象应该是接口或者基类。</li>
<li>任何具体类都不应该派生出子类。</li>
<li>尽量不要覆写基类中的方法。</li>
<li>结合里氏代换原则使用。</li>
</ul>
<h1 id="接口分离原则（INTERFACE-SEGREGATION-PRINCIPLE-ISP）"><a href="#接口分离原则（INTERFACE-SEGREGATION-PRINCIPLE-ISP）" class="headerlink" title="接口分离原则（INTERFACE SEGREGATION PRINCIPLE, ISP）"></a>接口分离原则（INTERFACE SEGREGATION PRINCIPLE, ISP）</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少。</p>
<h2 id="如何使用-2"><a href="#如何使用-2" class="headerlink" title="如何使用"></a>如何使用</h2><ul>
<li>使用接口隔离原则前首先需要满足单一职责原则。</li>
<li>接口需要高内聚，也就是提高接口、类、模块的处理能力，少对外发布public的方法。</li>
<li>定制服务，就是单独为一个个体提供优良的服务，简单来说就是拆分接口，对特定接口进行定制。</li>
<li>接口设计是有限度的，接口的设计粒度越小，系统越灵活，但是值得注意不能过小，否则变成”字节码编程”。</li>
</ul>
<h1 id="合成-复用原则（COMPOSITE-AGGREGATE-REUSE-PRINCIPLE-CARP）"><a href="#合成-复用原则（COMPOSITE-AGGREGATE-REUSE-PRINCIPLE-CARP）" class="headerlink" title="合成/复用原则（COMPOSITE/AGGREGATE REUSE PRINCIPLE, CARP）"></a>合成/复用原则（COMPOSITE/AGGREGATE REUSE PRINCIPLE, CARP）</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;尽量使用合成/聚合，而不是通过继承达到复用的目的。就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向内部持有的这些对象的委派达到复用已有功能的目的，而不是通过继承来获得已有的功能。</p>
<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>&emsp;&emsp;合成表示一种强的“拥有”关系，一般表现为严格的整体和部分的关系，部分和整体的生命周期是一样的。</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>&emsp;&emsp;聚合表示一种弱的“拥有”关系，一般表现为松散的整体和部分的关系，其实，所谓整体和部分也可以是完全不相关的。例如A对象持有B对象，B对象并不是A对象的一部分，也就是B对象的生命周期是B对象自身管理，和A对象不相关。</p>
<h2 id="为什么用合成-聚合来代替继承达到复用的目的？"><a href="#为什么用合成-聚合来代替继承达到复用的目的？" class="headerlink" title="为什么用合成/聚合来代替继承达到复用的目的？"></a>为什么用合成/聚合来代替继承达到复用的目的？</h2><p>&emsp;&emsp;继承复用破坏包装，因为继承将基类的实现细节暴露给子类，基类的内部细节通常对子类来说是可见的，这种复用也成为“白箱复用”。这里有一个明显的问题是：子类继承自基类，如果基类的实现发生改变，将会影响到所有子类的实现，如果从基类继承而来的实现是静态的，不可能在运行时发生改变，不够灵活。</p>
<p>&emsp;&emsp;由于合成或聚合关系可以将已有的对象，一般叫成员对象，纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为”黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成/聚合复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p>
<p>&emsp;&emsp;如果有阅读过《Effective Java 2nd》的同学就知道，此书也建议慎用继承。一般情况下，只有明确知道派生类和基类满<code>IS A</code>的时候才选用继承，当满足<code>HAS A</code>或者不能判断的情况下应该选用合成/聚合。</p>
<h1 id="迪米特原则（LAW-OF-DEMETER-LOD）"><a href="#迪米特原则（LAW-OF-DEMETER-LOD）" class="headerlink" title="迪米特原则（LAW OF DEMETER, LOD）"></a>迪米特原则（LAW OF DEMETER, LOD）</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;迪米特原则，也叫最少知道原则，它的定义是：一个软件实体应当尽可能少地与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知道，而且局限于那些与本单位密切相关的软件单位。迪米特原则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特原则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类（中间类或者跳转类）来转达。</p>
<h2 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h2><p>&emsp;&emsp;迪米特法则的核心观念就是类间解耦，也就降低类之间的耦合，只有类处于弱耦合状态，类的复用率才会提高。所谓降低类间耦合，实际上就是尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。但是这样会引发一个问题，有可能产生大量的中间类或者跳转类，导致系统的复杂性提高，可维护性降低。如果一味追求极度解耦，那么最终有可能变成面向字节码编程甚至是面向二进制的0和1编程。</p>
<h2 id="如何使用-3"><a href="#如何使用-3" class="headerlink" title="如何使用"></a>如何使用</h2><ul>
<li>Only talk to your immediate friends(只与直接的朋友通讯)，一个对象的”朋友”包括他本身(this)、它持有的成员对象、入参对象、它所创建的对象。</li>
<li>尽量少发布public的变量和方法，一旦公开的属性和方法越多，修改的时候影响的范围越大。</li>
<li>“是自己的就是自己的”，如果一个方法放在本类中，既不产生新的类间依赖，也不造成负面的影响，那么次方法就应该放在本类中。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《Java设计模式》</li>
<li>《设计模式之禅》</li>
<li>《设计模式-可复用面向对象软件的基础》</li>
</ul>
<p>（本文完）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GoatSheep</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://goatsheep999.github.io/goat/1545206466/">https://goatsheep999.github.io/goat/1545206466/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">转载请注明来自 <a href="https://goatsheep999.github.io">GoatSheep</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式    </a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象    </a><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">设计原则    </a></div><div class="post_share"><div class="social-share" data-image="https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/shejiyuanze.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/goat/4223960172/"><img class="prev_cover lazyload" data-src="https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/Effective Java.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Effective Java学习笔记</span></div></a></div><div class="next-post pull_right"><a href="/goat/factory_method/"><img class="next_cover lazyload" data-src="https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/shejimoshi.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>设计模式之工厂方法模式</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/goat/2580072625/" title="设计模式之简单工厂模式"><img class="relatedPosts_cover lazyload"data-src="https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/shejimoshi.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-03</div><div class="relatedPosts_title">设计模式之简单工厂模式</div></div></a></div><div class="relatedPosts_item"><a href="/goat/factory_method/" title="设计模式之工厂方法模式"><img class="relatedPosts_cover lazyload"data-src="https://github.com/goatsheep999/goatsheep999.github.io/raw/master/img/shejimoshi.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-05</div><div class="relatedPosts_title">设计模式之工厂方法模式</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By GoatSheep</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/activate-power-mode/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true; 
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>